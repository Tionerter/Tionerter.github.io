<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Lua中Table表</title>
      <link href="/posts/90b62093/"/>
      <url>/posts/90b62093/</url>
      
        <content type="html"><![CDATA[<h1 id="元表和元方法"><a href="#元表和元方法" class="headerlink" title="元表和元方法"></a>元表和元方法</h1><h2 id="使用元表和元方法"><a href="#使用元表和元方法" class="headerlink" title="使用元表和元方法"></a>使用元表和元方法</h2><p>元表：修改一个值（如字符串，表）在面对一个未知操作（如加减乘除）的行为<br>元方法：在元表中查询面对未知操作时所对应的字段（可以是方法，值，或者其他）<br>Lua中每一个值都可以有元表，除了table和userdata具有各自相互独立的元表，其他的类型共享对应类型所属的同一个元表。字符串有默认元表，其他的类型默认没有<br>多个表可以共享一个表，表也可以成为自身的元表</p><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">t=&#123;&#125;</span><br><span class="line">mt=&#123;&#125;</span><br><span class="line">mt.<span class="built_in">__add</span>=<span class="literal">nil</span><span class="comment">--加</span></span><br><span class="line">mt.<span class="built_in">__sub</span>=<span class="literal">nil</span><span class="comment">--减</span></span><br><span class="line">mt.<span class="built_in">__mul</span>=<span class="literal">nil</span><span class="comment">--乘</span></span><br><span class="line">mt.<span class="built_in">__tostring</span>=<span class="literal">nil</span><span class="comment">--对应toring方法</span></span><br><span class="line">mt.__metatbale=<span class="string">&quot;不可修改&quot;</span><span class="comment">--设置mt表的元表为不可修改，getmetatable放回这个值，setmetable抛出错误</span></span><br><span class="line">mt.__pairs=<span class="literal">nil</span><span class="comment">--对应pairs方法</span></span><br><span class="line"><span class="built_in">setmetatable</span>(t,mt)<span class="comment">--设置mt作为t的元表</span></span><br><span class="line"><span class="built_in">getmetatable</span>(t)</span><br></pre></td></tr></table></figure><p>当一个表达式混合了两种不同的元表的值时</p><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">s=t+<span class="number">8</span></span><br></pre></td></tr></table></figure><p>如果第一个值有元表且元表中有所需的元方法，那么就调用，反之就看第二个值是否有元表是否有对应元方法，如果都无Lua抛出异常</p><h2 id="index元方法"><a href="#index元方法" class="headerlink" title="__index元方法"></a>__index元方法</h2><p>访问表中不存在的元素，实际会在元表中查找__index字段，如果该字段是一个表就继续在该表中查找</p><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">prototype=&#123;x=<span class="number">0</span>,y=<span class="number">1</span>,z=<span class="number">3</span>&#125;</span><br><span class="line">t=&#123;&#125;</span><br><span class="line">mt=&#123;&#125;</span><br><span class="line">mt.<span class="built_in">__index</span>=<span class="function"><span class="keyword">function</span><span class="params">(_,key)</span></span><span class="comment">--index作为方法时，第一个参数是传入的表</span></span><br><span class="line">    <span class="keyword">return</span> prototype[key]</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="built_in">setmetatable</span>(t,mt)</span><br><span class="line"><span class="built_in">print</span>(t.y)<span class="comment">--输出1</span></span><br><span class="line"><span class="comment">--可以进一步化简</span></span><br><span class="line">mt.<span class="built_in">__index</span>=prototype</span><br><span class="line"><span class="built_in">print</span>(t.z)<span class="comment">--输出3</span></span><br></pre></td></tr></table></figure><p>如果__index字段是一个表，就在表中查找，如果表中没有，就看这个表是否有元表，元表中是否有__index方法，方法是否是一个表，如果是就在表中查找….</p><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">prototype=&#123;x=<span class="number">0</span>,y=<span class="number">1</span>,z=<span class="number">3</span>&#125;</span><br><span class="line">mt2=&#123;&#125;</span><br><span class="line"><span class="built_in">setmetatable</span>(mt2,&#123;<span class="built_in">__index</span>=prototype&#125;)</span><br><span class="line">mt=&#123;<span class="built_in">__index</span>=mt2&#125;</span><br><span class="line">t=&#123;&#125;</span><br><span class="line"><span class="built_in">setmetatable</span>(t,mt)</span><br><span class="line"><span class="built_in">setmetatable</span>(mt,mt2)</span><br><span class="line"><span class="built_in">print</span>(mt.x) <span class="comment">--输出0</span></span><br><span class="line"><span class="built_in">print</span>(t.x)<span class="comment">--输出0</span></span><br></pre></td></tr></table></figure><h2 id="newindex元方法"><a href="#newindex元方法" class="headerlink" title="__newindex元方法"></a>__newindex元方法</h2><p>对表中不存在的元素进行赋值，实际会在查找元表中的__newindex字段，机制与__index类似，如果是一个方法就调用方法，如果是表就对这个表进行赋值</p><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">prototype=&#123;x=<span class="number">0</span>,y=<span class="number">1</span>,z=<span class="number">3</span>&#125;</span><br><span class="line">mt2=&#123;&#125;</span><br><span class="line"><span class="built_in">setmetatable</span>(mt2,&#123;<span class="built_in">__newindex</span>=prototype&#125;)</span><br><span class="line">mt=&#123;<span class="built_in">__newindex</span>=mt2&#125;</span><br><span class="line">t=&#123;&#125;</span><br><span class="line"><span class="built_in">setmetatable</span>(t,mt)</span><br><span class="line"><span class="built_in">setmetatable</span>(mt,mt2)</span><br><span class="line">t.x=<span class="number">100</span><span class="comment">--修改prototype表中的x字段，改为100，t依旧是空表</span></span><br></pre></td></tr></table></figure><h1 id="面向对象实现"><a href="#面向对象实现" class="headerlink" title="面向对象实现"></a>面向对象实现</h1><h2 id="表中的self标识"><a href="#表中的self标识" class="headerlink" title="表中的self标识"></a>表中的self标识</h2><p>Lua的表中含有一个隐藏的self标识用来指代自身，类似this指针<br>如果在函数中不使用self，只有特定对象的名称保持不变，函数才可以正常工作</p><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">father=&#123;age =<span class="number">100</span>&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">father.Age</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">return</span> father.age</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="built_in">print</span>(father.Age())</span><br><span class="line">other,father=father,<span class="literal">nil</span></span><br><span class="line"><span class="built_in">print</span>(other.Age())<span class="comment">--attempt to index a nil value (global &#x27;father&#x27;)</span></span><br></pre></td></tr></table></figure><p>使用self替代对全局变量的使用</p><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">father=&#123;age =<span class="number">100</span>&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">father.Age</span><span class="params">(self)</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">self</span>.age</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="built_in">print</span>(father.Age(father))</span><br><span class="line">other,father=father,<span class="literal">nil</span></span><br><span class="line"><span class="built_in">print</span>(other.Age(other))<span class="comment">--现在函数调用，不需要让特定对象的名称保持不变</span></span><br><span class="line"><span class="built_in">print</span>(other:Age())<span class="comment">--&quot;:&quot;是一种语法糖，用来隐藏传入的self参数</span></span><br></pre></td></tr></table></figure><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p>通过在生成函数中对self的使用和元表的使用，创建一个空的表，并将father表作为其元表，在后续使用father表中函数时，传入的self不再是指代father表，而是传入的其他表</p><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">father=&#123;age =<span class="number">100</span>&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">father:New</span><span class="params">(o)</span></span><span class="comment">--语法糖，隐藏传入的self参数</span></span><br><span class="line">    <span class="keyword">local</span> o =o <span class="keyword">or</span> &#123;&#125;</span><br><span class="line">    <span class="built_in">self</span>.<span class="built_in">__index</span>=<span class="built_in">self</span></span><br><span class="line">    <span class="built_in">setmetatable</span>(o,<span class="built_in">self</span>)</span><br><span class="line">    <span class="keyword">return</span> o</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">father.Age</span><span class="params">(self)</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">self</span>.age</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">father:ChangeAge</span><span class="params">(num)</span></span></span><br><span class="line">    <span class="built_in">self</span>.age=num</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">a=father:New()</span><br><span class="line"><span class="built_in">print</span>(a:Age()) <span class="comment">--输出100</span></span><br><span class="line">a:ChangeAge(<span class="number">090</span>)<span class="comment">--这步传入的self指代的是a，会直接在a中添加一个age字段，Age函数依旧是通过元表的__index从father调用</span></span><br><span class="line">b=father:New()</span><br><span class="line"><span class="built_in">print</span>(b.Age(b)) <span class="comment">--输出100，a,b都成为了father的实例</span></span><br></pre></td></tr></table></figure><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>通过对元表的设置，进而实现子类继承父类的东西</p><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">father=&#123;age =<span class="number">100</span>&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">father:New</span><span class="params">(o)</span></span></span><br><span class="line">    <span class="keyword">local</span> o =o <span class="keyword">or</span> &#123;&#125;</span><br><span class="line">    <span class="built_in">self</span>.<span class="built_in">__index</span>=<span class="built_in">self</span></span><br><span class="line">    <span class="built_in">setmetatable</span>(o,<span class="built_in">self</span>)</span><br><span class="line">    <span class="keyword">return</span> o</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">father:Age</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">self</span>.age</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">a=father:New()<span class="comment">--a是father的一个实例</span></span><br><span class="line">b=a:New()<span class="comment">--调用a的New方法，传入的self指代a，返回一个以a为元表的空表</span></span><br><span class="line"><span class="built_in">print</span>(b:Age())<span class="comment">--调用a中的Age方法</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">father:ChangeAge</span><span class="params">(num)</span></span></span><br><span class="line">    <span class="built_in">self</span>.age=num</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">--先查找b中是否有ChangeAge方法，然后查找b的元表的__index,发现__index为一个表(a表)，在a表中查找，发现并没有</span></span><br><span class="line"><span class="comment">--进而查找a的元表的__index，发现指代一个表(father表)，在father表中查找，找到，调用father的ChangeAge方法。</span></span><br><span class="line"><span class="comment">--注意.这里传入的self指代b，最后会在b中创建一个age字段</span></span><br><span class="line"><span class="built_in">print</span>(b:ChangeAge(<span class="number">20</span>))</span><br></pre></td></tr></table></figure><h2 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h2><p>多重继承的实现，主要是利用元表的__index字段，将这个字段设置为一个方法，方法从parent列表中查找，是否有对应的方法，如果有就返回</p><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">search</span><span class="params">(k,list)</span></span></span><br><span class="line">    <span class="keyword">for</span> i = <span class="number">1</span>, #list <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">local</span> v=list[i][k]</span><br><span class="line">        <span class="keyword">if</span> k <span class="keyword">then</span></span><br><span class="line">            <span class="keyword">return</span> v</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> tb1=&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tb1:footb1</span><span class="params">()</span></span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;tb1&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">local</span> tb2=&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tb2:footb2</span><span class="params">()</span></span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;tb2&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">--以下应该是构造函数内的内容，构造函数形如funtion xx:new(...)</span></span><br><span class="line"><span class="comment">--local parent=&#123;...&#125;，初始化parent列表</span></span><br><span class="line"><span class="keyword">local</span> c=&#123;&#125;</span><br><span class="line"><span class="keyword">local</span> parent=&#123;tb1,tb2&#125;</span><br><span class="line"><span class="built_in">setmetatable</span>(c,&#123;<span class="built_in">__index</span>=<span class="function"><span class="keyword">function</span> <span class="params">(t,k)</span></span></span><br><span class="line">    <span class="keyword">return</span> search(k,parent)</span><br><span class="line"><span class="keyword">end</span>&#125;)</span><br><span class="line"><span class="comment">--最后返回c</span></span><br><span class="line">c.footb1()<span class="comment">--输出tb1</span></span><br><span class="line">c.footb2()<span class="comment">--输出tb2</span></span><br></pre></td></tr></table></figure><h1 id="底层"><a href="#底层" class="headerlink" title="底层"></a>底层</h1><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"3797dab9ae4cff55452a","clientSecret":"2ce066e1af402f16e2077122507b5810478a8aaf","repo":"blog_comment","owner":"Tionerter","admin":["Tionerter"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
      
      
      <categories>
          
          <category> Lua </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Lua </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AssetBundle</title>
      <link href="/posts/3b287ac7/"/>
      <url>/posts/3b287ac7/</url>
      
        <content type="html"><![CDATA[<h1 id="AssetBundle中的依赖关系"><a href="#AssetBundle中的依赖关系" class="headerlink" title="AssetBundle中的依赖关系"></a>AssetBundle中的依赖关系</h1><ul><li>出现依赖的情况</li></ul><p>假设有一个ab包A，A中有游戏物体a引用了另外一个ab包B中的游戏物体b，那么就可以说两者之间存在依赖</p><p>在尝试加载A包中的物体a时，要先确定加载了B包中的物体b，但A,B两个包的加载顺序不重要</p><ul><li>不出现依赖的情况</li></ul><p>但如果此时ab包A中引用的游戏物体b，并不存在于任何ab包中，那么在打包A包的时候就会拷贝一份b进入A包中，在单个包中还没有问题，但如果有多个ab包都引用了b，那么每一个ab包都会产生一份c的复制在自己的包内</p><p>对于多个ab共享的资源，需要单独打包成一个ab包，并在加载这些ab包之前，先加载这个共享的ab包</p><p>Untiy提供了一个加载依赖包的机制，在构成AB包时，会额外生成一个关于生成目录的AB包及其清单文件，可以通过加载这个AB包来获取依赖包的信息，来先加载依赖包</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//加载额外的AB包</span></span><br><span class="line">AssetBundle assetBundle = AssetBundle.LoadFromFile(manifestFilePath);</span><br><span class="line"><span class="comment">//从AB包中加载清单文件信息</span></span><br><span class="line">AssetBundleManifest manifest = assetBundle.LoadAsset&lt;AssetBundleManifest&gt;(<span class="string">&quot;AssetBundleManifest&quot;</span>);</span><br><span class="line"><span class="built_in">string</span>[] dependencies = manifest.GetAllDependencies(<span class="string">&quot;assetBundle&quot;</span>); <span class="comment">//Pass the name of the bundle you want the dependencies for.</span></span><br><span class="line"><span class="keyword">foreach</span>(<span class="built_in">string</span> dependency <span class="keyword">in</span> dependencies)</span><br><span class="line">&#123;</span><br><span class="line">    AssetBundle.LoadFromFile(Path.Combine(assetBundlePath, dependency));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="AssetBundle的构建"><a href="#AssetBundle的构建" class="headerlink" title="AssetBundle的构建"></a>AssetBundle的构建</h1><p>BuildAssetBundleOptions</p><ul><li><code>BuildAssetBundleOptions.None</code>: 使用LZMA压缩，包大小比使用LZ4小，但需要更多的加载时间，使用前需要被整个重新解压，然后再使用LZ4压缩缓存，这种格式下可以加载单个文件，而不需要解压整个包。如果AB包是通过UnityWebRequestAssetBundle下载得到的，会被自动解压然后再LZ4压缩缓存在本地，因为包小是网络传输优先使用的格式</li><li><code>BuildAssetBundleOptions.UncompressedAssetBundle</code>: 不压缩，导致包更大，但加载速度更快</li><li><code>BuildAssetBundleOptions.ChunkBasedCompression</code>: 直接使用LZ4压缩，基于块的算法，加载单个资产时直接解压包含该资产的块，而不需要解压整个包，产生的包比LZM4的包大，但加载速度与不压缩相当</li></ul><p>会生成2（n+1）个文件，2：具体分为具体类型的AB包和其清单文件.manifest，+1：还要额外生成一个关于生成目录的AB包和清单文件</p><h1 id="AssetBundle的加载和卸载"><a href="#AssetBundle的加载和卸载" class="headerlink" title="AssetBundle的加载和卸载"></a>AssetBundle的加载和卸载</h1><p>加载AB包</p><ul><li><p>AssetBundle.LoadFromMemoryAsync：如果加载的AB包是LZMA格式会自动解压，LZ4不会</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Example</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">IEnumerator <span class="title">LoadFromMemoryAsync</span>(<span class="params"><span class="built_in">string</span> path</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        AssetBundleCreateRequest createRequest = AssetBundle.LoadFromMemoryAsync(File.ReadAllBytes(path));</span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">return</span> createRequest;</span><br><span class="line">        AssetBundle bundle = createRequest.assetBundle;</span><br><span class="line">        <span class="keyword">var</span> prefab = bundle.LoadAsset&lt;GameObject&gt;(<span class="string">&quot;MyObject&quot;</span>);</span><br><span class="line">        Instantiate(prefab);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>AssetBundle.LoadFromFile：从本地读取AB的方法，如果是无压缩或者LZ4格式，加载速度会很快，如果是LZMA格式会在第一次加载的时候解压</p></li><li><p>UnityWebRequest和UnityWebRequestAssetBundle.GetAssetBundle：从指定的url下载AB包，UnityWebRequestAssetBundle.GetAssetBundle函数返回一个 UnityWebRequest，并将DownloadHandlerAssetBundle附加到返回的UnityWebRequest]。此DownloadHandler有一个特殊的DownloadHandlerAssetBundle.assetBundle属性，一旦下载并解码了足够多的数据就可以使用该属性来提取包内的资源。</p></li></ul><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function">IEnumerator <span class="title">GetText</span>()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">using</span> (UnityWebRequest uwr = UnityWebRequestAssetBundle.GetAssetBundle(<span class="string">&quot;https://www.my-server.com/mybundle&quot;</span>))</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">yield</span> <span class="keyword">return</span> uwr.SendWebRequest();</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (uwr.result != UnityWebRequest.Result.Success)</span><br><span class="line">       &#123;</span><br><span class="line">          Debug.Log(uwr.error);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">       &#123;</span><br><span class="line">          <span class="comment">// Get downloaded asset bundle</span></span><br><span class="line">          AssetBundle bundle = DownloadHandlerAssetBundle.GetContent(uwr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>卸载AB包<br>AssetBundle.Unload(bool)<br>true：卸载AB包，以及所有的从AB包中加载出来的资源及其依赖项，如果场景中有物体保持了引用，引用丢失。但不会卸载通过从AB包中加载的资源实例化生成的GameObject和复制的GameObject（这已经不属于AB包的东西）</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> prefab = myLoadedAssetBundle.LoadAllAssets&lt;GameObject&gt;();</span><br><span class="line"><span class="comment">//prefab是从AB包加载的内容，会被卸载</span></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; prefab.Length; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//实例生成的对象不会被卸载</span></span><br><span class="line">Instantiate(prefab[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2022-03-25-AssetBundle/image-20220325010851645.png" alt="image-20220325010851645"><br>false：卸载AB自身，并不会影响AB中已经加载出来的的资源，但会破坏实例链：</p><p>比如从AB包A中加载了一个material（没有对该材质的引用只是加载进内存），然后卸载A包，这个材质就是一个野资源，同时哪怕重新加载A包，该材质也不会和新加载的A包产生关联。Untiy提供Resources.UnloadUnusedAssets函数来处理这些野资源（显式或者在非附加加载新场景时自动调用）</p><p><img src="/2022-03-25-AssetBundle/image-20220325212226867.png" alt="image-20220325212226867"></p><h1 id="AssetBundle的缓存"><a href="#AssetBundle的缓存" class="headerlink" title="AssetBundle的缓存"></a>AssetBundle的缓存</h1><p>Untiy的AB包有两种缓存位置</p><ul><li><strong>内存缓存</strong>：以 UncompressedRuntime 格式将Ab包存储在RAM 中。</li><li><strong>磁盘缓存</strong>：以LZMA，LZ4或不压缩格式将获取的 AB包存储在磁盘上。</li></ul><p>通过UnityWebRequire（UWR）的获取的AB包，如果在下载AB包时向 UWR API 提供额外version参数，Unity 会把AB包缓存在磁盘中。如果不提供version参数，Unity 会缓存在内存中。version 参数可以是版本号或哈希值。如果<a href="https://docs.unity3d.com/ScriptReference/Caching-compressionEnabled.html">Caching.compressionEnabled</a>设置为 true，Unity 会在将 AssetBundle 写入磁盘以进行所有后续下载时应用 LZ4 压缩。它不会压缩缓存中现有的未压缩数据。如果<a href="https://docs.unity3d.com/ScriptReference/Caching-compressionEnabled.html">Caching.compressionEnabled</a>为 false，Unity 在将 AssetBundle 写入磁盘时不应用压缩。</p><p>通过AssetBundle.LoadFromFile或AssetBundle.LoadFromFileAsync加载的lZMA格式的AB包，总是缓存在内存，可以使用AssetBundle.RecompressAssetBundleAsync更改AB包的格式并缓存在磁盘上</p><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"3797dab9ae4cff55452a","clientSecret":"2ce066e1af402f16e2077122507b5810478a8aaf","repo":"blog_comment","owner":"Tionerter","admin":["Tionerter"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 资源管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Addressable</title>
      <link href="/posts/9da42dea/"/>
      <url>/posts/9da42dea/</url>
      
        <content type="html"><![CDATA[<p>1.什么是Asset</p><p>就是我们用来制作游戏的资源，列如.png .fbx .wav,在profect窗口所看到的东西</p><p>2.Asset是如何加入游戏里面的去的</p><p>（1）直接引用：直接把资源拖拽到Hierarchy</p><p>（2）间接引用：</p><p>3.为什么要使用Addressable</p><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"3797dab9ae4cff55452a","clientSecret":"2ce066e1af402f16e2077122507b5810478a8aaf","repo":"blog_comment","owner":"Tionerter","admin":["Tionerter"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 热更新 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
